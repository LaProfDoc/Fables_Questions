<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu des Fables de La Fontaine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Chosen Palette: Calm Harmony (Stone, Emerald, Amber, Blue, Red) -->
    <!-- Application Structure Plan: L'application est une page unique organisée en plusieurs vues gérées par JavaScript (écran de démarrage/configuration des joueurs, plateau de jeu, modale de question, modale de fin de partie, et désormais une modale de gestion des questions). Le plateau de jeu est une grille CSS flexible et réactive, avec des cases numérotées et visuellement distinctes. Les interactions clés incluent la saisie des noms des joueurs, le clic pour lancer le dé, l'affichage et la gestion des questions/réponses via une modale, la navigation entre les tours. Une nouvelle section de gestion des questions permet l'ajout, la modification et la suppression de contenu via localStorage. Cette structure est choisie pour sa clarté et sa simplicité, permettant une transition fluide entre les phases de jeu et une exploration intuitive pour les élèves et les enseignants. -->
    <!-- Visualization & Content Choices: La "Source Report" ici est la description du jeu lui-même. L'objectif est de traduire ces règles en une expérience interactive et d'ajouter une gestion de contenu. Le plateau de jeu (Goal: Organize/Play) est une grille HTML/CSS. Les pions des joueurs sont des emojis (Goal: Inform/Identify). Le dé est une simple mise à jour textuelle/numérique (Goal: Inform). Les questions sont des blocs de texte dynamiques (Goal: Inform/Challenge), présentés dans une modale. Une section de synthèse en fin de partie (Goal: Inform/Summarize) utilise un graphique à barres Chart.js pour visualiser les bonnes réponses par joueur. La gestion des questions (Goal: Organize/Manage) est une modale avec des listes et formulaires HTML/CSS gérés par JS et stockés dans localStorage. Des effets sonores (Tone.js) et visuels (CSS keyframes) ont été ajoutés pour renforcer l'immersion, incluant des confettis pour la victoire. Tous les éléments sont rendus avec HTML/CSS/JS et Chart.js, sans SVG ni Mermaid. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <style>
        body {
            font-family: 'Lato', sans-serif;
            background-color: #f5f5f4; /* stone-100 */
        }
        h1, h2, h3, .font-title {
            font-family: 'Merriweather', serif;
        }
        .board-cell {
            position: relative;
            background-color: #fcefdc; /* Light amber */
            border: 1px solid #d4c09d;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #44403c; /* stone-700 */
            aspect-ratio: 1 / 1; /* Keep cells square */
        }
        .player-token {
            position: absolute;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.5s ease-in-out; /* Smooth movement */
        }
        .bg-player-1 { background-color: #ef4444; } /* Red */
        .bg-player-2 { background-color: #3b82f6; } /* Blue */
        .bg-player-3 { background-color: #22c55e; } /* Green */
        .bg-player-4 { background-color: #f97316; } /* Orange */
        .bg-player-5 { background-color: #a855f7; } /* Purple */
        .bg-player-6 { background-color: #eab308; } /* Yellow */

        /* Specific cell styles */
        .cell-start { background-color: #a7f3d0; } /* emerald-200 */
        .cell-end { background-color: #a78bfa; } /* violet-400 */
        .cell-bonus { background-color: #bfdbfe; } /* blue-200 */
        .cell-trap { background-color: #fecaca; } /* red-200 */

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            text-align: center;
        }

        /* Correct Answer Visual Effect */
        .pulse-correct {
            animation: pulse-effect 1.5s ease-out; /* Longer duration */
        }

        @keyframes pulse-effect {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(16, 185, 129, 0.4); } /* emerald-500 */
            50% { transform: scale(1.005); box-shadow: 0 0 15px rgba(16, 185, 129, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(16, 185, 129, 0); }
        }

        /* Confetti Styles */
        #confetti-container {
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 2000; /* Ensure it's above other elements */
        }

        .confetti-particle {
            position: absolute;
            background-color: transparent; /* Will be set by JS */
            border-radius: 50%; /* For round confetti */
            opacity: 0.9;
            transform-origin: center center;
            will-change: transform, opacity; /* Optimize animations */
        }

        @keyframes fall {
            0% { transform: translateY(0) rotateZ(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0.5; }
        }

        @keyframes rotate {
            0% { transform: rotateY(0deg) rotateX(0deg); }
            100% { transform: rotateY(360deg) rotateX(360deg); }
        }
    </style>
</head>
<body class="text-stone-800">

    <div id="app" class="container mx-auto p-4 md:p-6 max-w-6xl min-h-screen flex flex-col">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-5xl font-title font-bold text-stone-700">Le Grand Jeu des Fables</h1>
            <h2 class="text-xl md:text-2xl font-title text-stone-500">Un Voyage avec La Fontaine</h2>
        </header>

        <!-- Player Setup Screen -->
        <section id="player-setup-screen" class="flex flex-col items-center justify-center flex-grow p-4">
            <div class="bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-6 md:p-8 max-w-md w-full">
                <h3 class="text-2xl font-bold font-title text-stone-700 mb-4">Préparation des Joueurs</h3>
                <div id="player-inputs" class="space-y-3 mb-6">
                    <!-- Player input fields will be added here -->
                </div>
                <button id="add-player-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mr-2">Ajouter un Joueur</button>
                <button id="start-game-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform duration-200 hover:scale-105">Démarrer le Jeu</button>
                <button id="manage-questions-btn" class="bg-stone-500 hover:bg-stone-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mt-4 w-full">Gérer les Questions</button>
            </div>
        </section>

        <!-- Game Play Screen -->
        <section id="game-play-screen" class="hidden flex-grow flex flex-col md:flex-row gap-6">
            
            <div id="game-board-container" class="order-2 md:order-1 bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-4 flex-grow grid grid-cols-5 auto-rows-min gap-2 md:gap-3">
                <!-- Board cells will be dynamically generated here -->
            </div>

            <div class="order-1 md:order-2 md:w-1/3 flex flex-col gap-4">
                <div class="bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-4 text-center">
                    <p class="text-lg md:text-xl font-semibold">C'est au tour de:</p>
                    <p id="current-player-name" class="text-2xl md:text-3xl font-bold font-title text-blue-600 mb-2"></p>
                    <p class="text-xl md:text-2xl font-bold">Dé:</p>
                    <div id="dice-display" class="text-5xl font-extrabold text-stone-700 mb-4 animate-bounce">?</div>
                    <button id="roll-dice-btn" class="bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform duration-200 hover:scale-105">Lancer le Dé</button>
                </div>

                <div class="bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-4">
                    <h3 class="text-xl font-bold font-title text-stone-700 mb-2 text-center">Positions des Joueurs</h3>
                    <ul id="player-positions-list" class="space-y-2">
                        <!-- Player positions will be listed here -->
                    </ul>
                </div>
            </div>
        </section>

        <!-- Question Modal -->
        <div id="question-modal" class="modal hidden">
            <div class="modal-content max-w-lg">
                <h3 class="text-2xl font-bold font-title text-stone-700 mb-4">Question !</h3>
                <p id="question-text" class="text-lg text-stone-700 mb-6"></p>
                <button id="reveal-answer-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105">Révéler la Réponse</button>
                <p id="answer-text" class="text-xl font-bold font-title text-emerald-700 mt-4 hidden"></p>
                <div class="flex justify-center gap-4 mt-6">
                    <button id="correct-answer-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 hidden">Bonne Réponse !</button>
                    <button id="wrong-answer-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 hidden">Mauvaise Réponse</button>
                </div>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal hidden">
            <div class="modal-content max-w-2xl">
                <h3 id="game-over-title" class="text-3xl font-bold font-title text-stone-700 mb-4">Partie Terminée !</h3>
                <p id="game-over-message" class="text-xl text-stone-700 mb-6"></p>
                
                <div class="bg-gray-50 rounded-lg p-4 mb-6">
                    <h4 class="text-xl font-bold font-title text-stone-700 mb-3">Statistiques des Questions</h4>
                    <div class="chart-container w-full max-w-xl mx-auto h-[300px] md:h-[400px]">
                        <canvas id="correct-answers-chart"></canvas>
                    </div>
                </div>

                <button id="play-again-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform duration-200 hover:scale-105">Rejouer</button>
            </div>
        </div>

        <!-- Question Management Modal -->
        <div id="question-management-modal" class="modal hidden">
            <div class="modal-content max-w-2xl">
                <h3 class="text-2xl font-bold font-title text-stone-700 mb-4">Gérer les Questions</h3>
                
                <div class="text-left mb-6">
                    <h4 class="text-xl font-bold mb-2">Ajouter/Modifier une Question</h4>
                    <input type="hidden" id="question-id-field">
                    <label for="question-input" class="block text-stone-700 text-sm font-bold mb-1">Question :</label>
                    <textarea id="question-input" class="shadow appearance-none border rounded w-full py-2 px-3 text-stone-700 leading-tight focus:outline-none focus:shadow-outline mb-3" rows="3"></textarea>
                    
                    <label for="answer-input" class="block text-stone-700 text-sm font-bold mb-1">Réponse :</label>
                    <input type="text" id="answer-input" class="shadow appearance-none border rounded w-full py-2 px-3 text-stone-700 leading-tight focus:outline-none focus:shadow-outline mb-3">
                    
                    <button id="save-question-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg shadow transition-transform duration-200 hover:scale-105 mr-2">Sauvegarder la Question</button>
                    <button id="cancel-edit-btn" class="bg-stone-400 hover:bg-stone-500 text-white font-bold py-2 px-4 rounded-lg shadow transition-transform duration-200 hover:scale-105">Annuler</button>
                </div>

                <div class="text-left">
                    <h4 class="text-xl font-bold mb-2">Liste des Questions</h4>
                    <ul id="questions-list" class="space-y-2 max-h-80 overflow-y-auto border border-stone-200 p-2 rounded-md">
                        <!-- Questions will be listed here -->
                    </ul>
                </div>
                
                <button id="close-management-modal-btn" class="bg-stone-600 hover:bg-stone-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mt-6">Fermer</button>
            </div>
        </div>

    </div>

    <!-- Confetti container -->
    <div id="confetti-container" class="fixed inset-0 overflow-hidden hidden"></div>

    <script>
        // Définition de la fonction shuffle, déplacée plus haut pour garantir sa disponibilité
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        const defaultQuestions = [
            { id: 'q1', q: "Qui suis-je ? Je suis paresseuse et je chante tout l'été, sans penser à l'hiver.", a: "La Cigale" },
            { id: 'q2', q: "Quel est le titre de la fable où un animal rusé vole le fromage d'un oiseau vaniteux ?", a: "Le Corbeau et le Renard" },
            { id: 'q3', q: "Comment appelle-t-on la leçon de vie ou la conclusion didactique à la fin d'une fable ?", a: "La Moralité" },
            { id: 'q4', q: "Qui suis-je ? Je suis fort et puissant, mais je peux être clément envers les petits.", a: "Le Lion" },
            { id: 'q5', q: "Quel est le titre de la fable où le plus fort impose sa loi au plus faible ?", a: "Le Loup et l'Agneau" },
            { id: 'q6', q: "Comment s'appelle un vers de douze syllabes, très utilisé en poésie classique française ?", a: "L'Alexandrin" },
            { id: 'q7', q: "Qui suis-je ? Je suis très prévoyante et je travaille sans relâche pendant que d'autres s'amusent.", a: "La Fourmi" },
            { id: 'q8', q: "Quel est le titre de la fable où un lent mais persévérant gagne une course contre un rapide mais arrogant ?", a: "Le Lièvre et la Tortue" },
            { id: 'q9', q: "Comment appelle-t-on la répétition de sons identiques à la fin de deux ou plusieurs vers ?", a: "La Rime" },
            { id: 'q10', q: "Qui suis-je ? Je suis très lent et mon corps est recouvert d'une carapace.", a: "La Tortue" },
            { id: 'q11', q: "Quel est le titre de la fable où un arbre solide plie devant un événement, contrairement à un autre plus souple ?", a: "Le Chêne et le Roseau" },
            { id: 'q12', q: "Comment appelle-t-on un récit court et imagé, souvent avec des animaux qui parlent, et qui contient une leçon de vie ?", a: "Une Fable" },
            { id: 'q13', q: "Qui suis-je ? Je suis assoiffé, mais le courant m'empêche de boire en paix près de mon ennemi.", a: "L'Agneau" },
            { id: 'q14', q: "Quel est le titre de la fable où une femme rêve de vendre le lait de son pot, mais casse tout par mégarde ?", a: "La Laitière et le Pot au Lait" },
            { id: 'q15', q: "Comment appelle-t-on le fait qu'une voyelle ou un 'e' muet ne soit pas prononcé à la fin d'un mot, devant une autre voyelle, pour compter les syllabes d'un vers ?", a: "L'Élision" },
            { id: 'q16', q: "Qui suis-je ? Je me suis fait très gros pour ressembler à un bœuf, mais j'ai fini par éclater.", a: "La Grenouille" },
            { id: 'q17', q: "Quel est le titre de la fable où les animaux sont malades, et le loup propose un coupable ?", a: "Les Animaux malades de la peste" },
            { id: 'q18', q: "Comment s'appelle un vers de huit syllabes ?", a: "L'Octosyllabe" },
            { id: 'q19', q: "Qui suis-je ? J'ai échappé à mon ennemi en lui faisant chanter une chanson pour lui voler son repas.", a: "Le Corbeau" },
            { id: 'q20', q: "Quel est le titre de la fable qui oppose la vie agitée de la ville à la vie tranquille de la campagne ?", a: "Le Rat de ville et le Rat des champs" }
        ];

        const playerTokens = ['🐰', '🦊', '🐢', '🦁', '🐺', '🐜'];
        const boardLength = 35; // Cells from 0 to 34
        const specialCells = {
            4: { type: 'bonus', effect: 2, text: '+2 cases' },
            9: { type: 'trap', effect: -3, text: '-3 cases' },
            13: { type: 'bonus', effect: 3, text: '+3 cases' },
            18: { type: 'trap', effect: 'swap', text: 'Échange avec le moins avancé' },
            22: { type: 'bonus', effect: 5, text: '+5 cases' },
            27: { type: 'trap', effect: 'start', text: 'Retour à la case départ' }
        };

        let gameState = {
            players: [],
            board: [],
            currentTurnIndex: 0,
            gameStarted: false,
            gameOver: false,
            availableQuestionIds: [], // IDs of questions not yet asked in current game
            questionsData: [], // All questions loaded from localStorage
            questionBeingAsked: null,
            correctAnswerGiven: false
        };

        const playerSetupScreen = document.getElementById('player-setup-screen');
        const playerInputsDiv = document.getElementById('player-inputs');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const manageQuestionsBtn = document.getElementById('manage-questions-btn');
        const gamePlayScreen = document.getElementById('game-play-screen');
        const gameBoardContainer = document.getElementById('game-board-container');
        const currentPlayerNameSpan = document.getElementById('current-player-name');
        const diceDisplay = document.getElementById('dice-display');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const playerPositionsList = document.getElementById('player-positions-list');
        const questionModal = document.getElementById('question-modal');
        const questionText = document.getElementById('question-text');
        const revealAnswerBtn = document.getElementById('reveal-answer-btn');
        const answerText = document.getElementById('answer-text');
        const correctBtn = document.getElementById('correct-answer-btn');
        const wrongBtn = document.getElementById('wrong-answer-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const playAgainBtn = document.getElementById('play-again-btn');
        const correctAnswersChartCanvas = document.getElementById('correct-answers-chart');
        let correctAnswersChart = null;

        const questionManagementModal = document.getElementById('question-management-modal');
        const questionsList = document.getElementById('questions-list');
        const questionIdField = document.getElementById('question-id-field');
        const questionInput = document.getElementById('question-input');
        const answerInput = document.getElementById('answer-input');
        const saveQuestionBtn = document.getElementById('save-question-btn');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const closeManagementModalBtn = document.getElementById('close-management-modal-btn');

        // Confetti variables
        let confettiInterval;
        let confettiDuration = 30000; // 30 seconds
        let confettiCount = 0;
        const maxConfetti = 200; 
        const confettiContainer = document.getElementById('confetti-container');

        // --- Tone.js Sound Setups ---
        const bonusSynth = new Tone.MembraneSynth().toDestination();
        // Adjusting trapSynth for a longer, more eerie sound
        const trapSynth = new Tone.DuoSynth({
            "vibratoAmount": 0.5,
            "vibratoRate": 5,
            "harmonicity": 1.5,
            "voice0": {
                "volume": -10,
                "portamento": 0,
                "oscillator": { "type": "sine" },
                "filterEnvelope": {
                    "attack": 0.01,
                    "decay": 1.0, // Longer decay
                    "sustain": 0.4,
                    "release": 1.0, // Longer release
                    "baseFrequency": 200,
                    "octaves": 4,
                    "exponent": 2
                },
                "envelope": {
                    "attack": 0.01,
                    "decay": 0.5,
                    "sustain": 0.4,
                    "release": 2.0 // Very long release
                }
            },
            "voice1": {
                "volume": -10,
                "portamento": 0,
                "oscillator": { "type": "sine" },
                "filterEnvelope": {
                    "attack": 0.01,
                    "decay": 1.0, // Longer decay
                    "sustain": 0.4,
                    "release": 1.0, // Longer release
                    "baseFrequency": 200,
                    "octaves": 4,
                    "exponent": 2
                },
                "envelope": {
                    "attack": 0.01,
                    "decay": 0.5,
                    "sustain": 0.4,
                    "release": 2.0 // Very long release
                }
            }
        }).toDestination();


        function playBonusSound() {
            bonusSynth.triggerAttackRelease("C5", "4n"); // Longer duration for bonus
        }

        function playTrapSound() {
            trapSynth.triggerAttackRelease("C3", "2n"); // Longer duration for trap
        }

        function createConfetti() {
            if (confettiCount >= maxConfetti) return;

            const confetti = document.createElement('div');
            confetti.classList.add('confetti-particle');
            
            const colors = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#a855f7', '#eab308'];
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            
            const size = Math.random() * 10 + 5; // 5px to 15px
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.top = `-${size}px`; // Start above screen
            
            const duration = Math.random() * 3 + 2; // 2s to 5s
            const delay = Math.random() * 0.5; // 0s to 0.5s
            confetti.style.animation = `fall ${duration}s linear ${delay}s infinite, rotate ${Math.random() * 2 + 1}s linear infinite`;
            
            confettiContainer.appendChild(confetti);
            confettiCount++;

            // Remove confetti after it falls off screen (or a bit after its animation duration)
            setTimeout(() => {
                if (confetti.parentNode) {
                    confetti.parentNode.removeChild(confetti);
                    confettiCount--;
                }
            }, (duration + delay) * 1000 + 500); 
        }

        function startConfetti() {
            confettiContainer.classList.remove('hidden');
            confettiCount = 0;
            for (let i = 0; i < 50; i++) {
                createConfetti();
            }
            confettiInterval = setInterval(createConfetti, 100);

            setTimeout(() => {
                clearInterval(confettiInterval);
                stopConfetti();
            }, confettiDuration);
        }

        function stopConfetti() {
            if (confettiInterval) {
                clearInterval(confettiInterval);
            }
            confettiContainer.classList.add('hidden');
            confettiContainer.innerHTML = '';
            confettiCount = 0;
        }


        // --- Question Management Logic ---
        function loadQuestions() {
            const storedQuestions = localStorage.getItem('fablesQuestions');
            if (storedQuestions) {
                try {
                    gameState.questionsData = JSON.parse(storedQuestions);
                } catch (e) {
                    console.error("Error parsing stored questions, loading default.", e);
                    gameState.questionsData = defaultQuestions;
                    saveQuestions(); // Save defaults if parsing fails
                }
            } else {
                gameState.questionsData = defaultQuestions;
                saveQuestions();
            }
        }

        function saveQuestions() {
            localStorage.setItem('fablesQuestions', JSON.stringify(gameState.questionsData));
            renderQuestionsList(); // Update UI after saving
        }

        function generateUniqueId() {
            return 'q' + Date.now() + Math.random().toString(36).substr(2, 9);
        }

        function renderQuestionsList() {
            questionsList.innerHTML = '';
            if (gameState.questionsData.length === 0) {
                questionsList.innerHTML = '<li class="text-stone-500">Aucune question n\'a été ajoutée.</li>';
                return;
            }
            gameState.questionsData.forEach(q => {
                const li = document.createElement('li');
                li.className = 'flex flex-col md:flex-row justify-between items-start md:items-center p-2 border-b border-stone-200 last:border-b-0';
                li.innerHTML = `
                    <div class="flex-grow text-sm mb-2 md:mb-0">
                        <p class="font-semibold text-stone-700">${q.q}</p>
                        <p class="text-stone-500">Réponse: ${q.a}</p>
                    </div>
                    <div class="flex gap-2">
                        <button data-id="${q.id}" class="edit-question-btn bg-yellow-500 hover:bg-yellow-600 text-white text-xs py-1 px-2 rounded-md shadow-sm">Modifier</button>
                        <button data-id="${q.id}" class="delete-question-btn bg-red-500 hover:bg-red-600 text-white text-xs py-1 px-2 rounded-md shadow-sm">Supprimer</button>
                    </div>
                `;
                questionsList.appendChild(li);
            });

            document.querySelectorAll('.edit-question-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const qId = e.target.dataset.id;
                    const questionToEdit = gameState.questionsData.find(q => q.id === qId);
                    if (questionToEdit) {
                        questionIdField.value = questionToEdit.id;
                        questionInput.value = questionToEdit.q;
                        answerInput.value = questionToEdit.a;
                    }
                });
            });

            document.querySelectorAll('.delete-question-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const qId = e.target.dataset.id;
                    gameState.questionsData = gameState.questionsData.filter(q => q.id !== qId);
                    saveQuestions();
                });
            });
        }

        function clearQuestionForm() {
            questionIdField.value = '';
            questionInput.value = '';
            answerInput.value = '';
        }

        saveQuestionBtn.addEventListener('click', () => {
            const id = questionIdField.value;
            const q = questionInput.value.trim();
            const a = answerInput.value.trim();

            if (!q || !a) {
                alert("Veuillez remplir la question et la réponse.");
                return;
            }

            if (id) {
                // Edit existing
                const index = gameState.questionsData.findIndex(item => item.id === id);
                if (index !== -1) {
                    gameState.questionsData[index] = { id, q, a };
                }
            } else {
                // Add new
                gameState.questionsData.push({ id: generateUniqueId(), q, a });
            }
            saveQuestions();
            clearQuestionForm();
        });

        cancelEditBtn.addEventListener('click', clearQuestionForm);

        manageQuestionsBtn.addEventListener('click', () => {
            loadQuestions(); // Ensure latest questions are loaded when opening
            renderQuestionsList();
            questionManagementModal.classList.remove('hidden');
            questionManagementModal.classList.add('flex');
        });

        closeManagementModalBtn.addEventListener('click', () => {
            questionManagementModal.classList.add('hidden');
            questionManagementModal.classList.remove('flex');
            clearQuestionForm(); // Clear form when closing
        });

        // --- Player Setup Logic ---
        let playerCount = 0;
        function addPlayerInput() {
            if (playerCount >= 6) return; // Max 6 players/teams
            playerCount++;
            const div = document.createElement('div');
            div.className = 'flex items-center gap-2';
            div.innerHTML = `
                <span class="font-bold text-lg text-stone-700">Joueur ${playerCount} (${playerTokens[playerCount - 1]}):</span>
                <input type="text" id="player-name-${playerCount}" placeholder="Nom de l'équipe" class="p-2 border border-stone-300 rounded-md flex-grow" value="Équipe ${playerCount}" />
            `;
            playerInputsDiv.appendChild(div);
        }

        // Initialize with 2 players by default
        addPlayerInput();
        addPlayerInput();

        addPlayerBtn.addEventListener('click', addPlayerInput);
        startGameBtn.addEventListener('click', initializeGame);
        playAgainBtn.addEventListener('click', () => {
            stopConfetti(); // Stop confetti if playing again
            gameOverModal.classList.add('hidden');
            playerSetupScreen.classList.remove('hidden');
            gamePlayScreen.classList.add('hidden');
            gameState = { players: [], board: [], currentTurnIndex: 0, gameStarted: false, gameOver: false, availableQuestionIds: [], questionsData: gameState.questionsData, questionBeingAsked: null, correctAnswerGiven: false }; // Keep questionsData
            playerInputsDiv.innerHTML = ''; // Clear previous inputs
            playerCount = 0;
            addPlayerInput();
            addPlayerInput();
            if (correctAnswersChart) {
                correctAnswersChart.destroy();
                correctAnswersChart = null;
            }
        });

        // --- Game Initialization ---
        function initializeGame() {
            loadQuestions(); // Ensure questions are loaded before starting a game
            if (gameState.questionsData.length === 0) {
                alert("La banque de questions est vide ! Veuillez ajouter des questions avant de commencer.");
                return;
            }

            gameState.players = [];
            for (let i = 1; i <= playerCount; i++) {
                const nameInput = document.getElementById(`player-name-${i}`);
                gameState.players.push({
                    name: nameInput.value || `Joueur ${i}`,
                    position: 0, // 0-indexed for array, represents cell 1
                    token: playerTokens[i - 1],
                    colorClass: `bg-player-${i}`,
                    correctAnswers: 0
                });
            }

            if (gameState.players.length < 2) {
                alert("Il faut au moins 2 joueurs pour démarrer le jeu !");
                return;
            }

            gameState.board = Array(boardLength).fill('normal');
            gameState.board[0] = 'start';
            gameState.board[boardLength - 1] = 'end'; // Last cell is end

            for (const pos in specialCells) {
                if (parseInt(pos) < boardLength - 1 ) { // Ensure special cells are not on the very last one
                    gameState.board[pos] = specialCells[pos].type;
                }
            }

            gameState.currentTurnIndex = Math.floor(Math.random() * gameState.players.length);
            gameState.gameStarted = true;
            gameState.gameOver = false;
            
            // Populate available questions for this game
            gameState.availableQuestionIds = gameState.questionsData.map(q => q.id);
            shuffle(gameState.availableQuestionIds); // Shuffle once at the beginning

            playerSetupScreen.classList.add('hidden');
            gamePlayScreen.classList.remove('hidden');
            renderBoard();
            updatePlayerPositionsList();
            updateCurrentPlayerDisplay();
        }

        // --- Board Rendering ---
        function renderBoard() {
            gameBoardContainer.innerHTML = '';
            for (let i = 0; i < boardLength; i++) {
                const cell = document.createElement('div');
                cell.className = 'board-cell shadow-sm';
                cell.textContent = i + 1; // Display 1-indexed number

                // Add specific styles for special cells
                if (i === 0) cell.classList.add('cell-start');
                else if (i === boardLength - 1) cell.classList.add('cell-end');
                else if (specialCells[i]) {
                    if (specialCells[i].type === 'bonus') cell.classList.add('cell-bonus');
                    else if (specialCells[i].type === 'trap') cell.classList.add('cell-trap');
                }
                
                cell.id = `cell-${i}`;
                gameBoardContainer.appendChild(cell);
            }
            placePlayerTokens();
        }

        function placePlayerTokens() {
            gameState.players.forEach(player => {
                const currentCell = document.getElementById(`cell-${player.position}`);
                if (currentCell) {
                    let token = document.getElementById(`token-${player.name.replace(/\s/g, '-')}`);
                    if (!token) {
                        token = document.createElement('div');
                        token.id = `token-${player.name.replace(/\s/g, '-')}`;
                        token.className = `player-token ${player.colorClass}`;
                        token.textContent = player.token;
                        token.title = player.name;
                    }
                    currentCell.appendChild(token);
                }
            });
        }

        function updatePlayerPositionsList() {
            playerPositionsList.innerHTML = '';
            gameState.players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'flex items-center justify-between text-lg';
                li.innerHTML = `
                    <span class="flex items-center gap-2">
                        <span class="${player.colorClass} w-5 h-5 rounded-full flex items-center justify-center text-sm text-white">${player.token}</span>
                        <span>${player.name}</span>
                    </span>
                    <span class="font-bold">${player.position + 1}</span>
                `;
                playerPositionsList.appendChild(li);
            });
        }

        function updateCurrentPlayerDisplay() {
            const currentPlayer = gameState.players[gameState.currentTurnIndex];
            currentPlayerNameSpan.textContent = currentPlayer.name;
            currentPlayerNameSpan.className = `text-2xl md:text-3xl font-bold font-title ${currentPlayer.colorClass.replace('bg-', 'text-')}`;
        }

        // --- Game Play Logic ---
        rollDiceBtn.addEventListener('click', rollDice);

        async function rollDice() {
            if (gameState.gameOver || gameState.questionActive) return;

            rollDiceBtn.disabled = true;
            diceDisplay.classList.remove('animate-bounce'); // Stop initial animation

            let rollCount = 0;
            const animationInterval = setInterval(() => {
                diceDisplay.textContent = Math.floor(Math.random() * 6) + 1;
                rollCount++;
                if (rollCount > 10) {
                    clearInterval(animationInterval);
                    const roll = Math.floor(Math.random() * 6) + 1;
                    diceDisplay.textContent = roll;
                    movePlayer(roll);
                    rollDiceBtn.disabled = false;
                }
            }, 100);
        }

        async function movePlayer(roll) {
            const currentPlayer = gameState.players[gameState.currentTurnIndex];
            let newPosition = currentPlayer.position + roll;

            if (newPosition >= boardLength -1) {
                newPosition = boardLength -1;
            }
            
            for (let i = currentPlayer.position; i < newPosition; i++) {
                await new Promise(resolve => setTimeout(() => {
                    currentPlayer.position = i + 1;
                    placePlayerTokens();
                    updatePlayerPositionsList();
                    resolve();
                }, 200));
            }

            currentPlayer.position = newPosition;
            placePlayerTokens();
            updatePlayerPositionsList();

            checkCell(newPosition);
        }

        async function checkCell(position) {
            if (position === boardLength - 1) {
                endGame(gameState.players[gameState.currentTurnIndex].name);
                return;
            }

            const cellType = gameState.board[position];
            
            if (specialCells[position]) {
                const effect = specialCells[position].effect;
                const currentPlayer = gameState.players[gameState.currentTurnIndex];
                
                let message = "";

                if (specialCells[position].type === 'bonus') {
                    playBonusSound(); // Play bonus sound
                } else if (specialCells[position].type === 'trap') {
                    playTrapSound(); // Play trap sound
                }


                if (effect === 'swap') {
                    const leastAdvancedPlayer = gameState.players.reduce((prev, curr) => 
                        curr.position < prev.position ? curr : prev, gameState.players[0]);
                    
                    if (leastAdvancedPlayer.name !== currentPlayer.name) {
                        const currentPlayerOldPos = currentPlayer.position;
                        const leastAdvancedPlayerOldPos = leastAdvancedPlayer.position;
                        
                        currentPlayer.position = leastAdvancedPlayerOldPos;
                        leastAdvancedPlayer.position = currentPlayerOldPos;
                        
                        message = `${currentPlayer.name} échange sa place avec ${leastAdvancedPlayer.name} !`;
                        placePlayerTokens();
                        updatePlayerPositionsList();
                    } else {
                        message = `${currentPlayer.name} est déjà le moins avancé. Rien ne se passe !`;
                    }
                     await showEventMessage("Événement Spécial !", message);
                     nextTurn();
                     return;

                } else if (effect === 'start') {
                    currentPlayer.position = 0;
                    message = `${currentPlayer.name} retourne à la case départ !`;
                    placePlayerTokens();
                    updatePlayerPositionsList();
                    await showEventMessage("Événement Spécial !", message);
                    nextTurn();
                    return;
                } else if (typeof effect === 'number') {
                    let newPos = currentPlayer.position + effect;
                    if (newPos < 0) newPos = 0;
                    if (newPos >= boardLength - 1) newPos = boardLength -1;
                    
                    currentPlayer.position = newPos;

                    if (effect > 0) {
                        message = `${currentPlayer.name} avance de ${effect} cases !`;
                    } else {
                        message = `${currentPlayer.name} recule de ${Math.abs(effect)} cases !`;
                    }
                    placePlayerTokens();
                    updatePlayerPositionsList();
                    await showEventMessage("Événement Spécial !", message);
                    nextTurn();
                    return;
                }
            }
            
            await askQuestion();
        }

        function showEventMessage(title, message) {
            return new Promise(resolve => {
                questionModal.classList.remove('hidden');
                questionModal.classList.add('flex');
                questionModal.querySelector('.modal-content h3').textContent = title;
                questionText.textContent = message;
                revealAnswerBtn.classList.add('hidden');
                answerText.classList.add('hidden');
                correctBtn.classList.add('hidden');
                wrongBtn.classList.add('hidden');

                const okButton = document.createElement('button');
                okButton.textContent = "OK";
                okButton.className = "bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mt-6";
                okButton.onclick = () => {
                    questionModal.classList.add('hidden');
                    questionModal.classList.remove('flex');
                    okButton.remove();
                    questionModal.querySelector('.modal-content h3').textContent = "Question !"; // Reset title
                    resolve();
                };
                questionModal.querySelector('.modal-content').appendChild(okButton);
            });
        }


        function askQuestion() {
            return new Promise(resolve => {
                gameState.questionActive = true;
                
                if (gameState.availableQuestionIds.length === 0) {
                    showEventMessage("Plus de questions !", "Vous avez répondu à toutes les questions disponibles ! La partie continue sans questions.");
                    gameState.questionActive = false; // Allow play to continue
                    resolve();
                    return;
                }

                // Pick a random question from available ones
                const randomIndex = Math.floor(Math.random() * gameState.availableQuestionIds.length);
                const questionId = gameState.availableQuestionIds[randomIndex];
                gameState.questionBeingAsked = gameState.questionsData.find(q => q.id === questionId);

                // Remove from available questions
                gameState.availableQuestionIds.splice(randomIndex, 1);

                questionText.textContent = gameState.questionBeingAsked.q;
                answerText.textContent = gameState.questionBeingAsked.a;

                answerText.classList.add('hidden');
                revealAnswerBtn.classList.remove('hidden');
                correctBtn.classList.add('hidden');
                wrongBtn.classList.add('hidden');

                questionModal.classList.remove('hidden');
                questionModal.classList.add('flex');

                revealAnswerBtn.onclick = () => {
                    answerText.classList.remove('hidden');
                    revealAnswerBtn.classList.add('hidden');
                    correctBtn.classList.remove('hidden');
                    wrongBtn.classList.remove('hidden');
                };

                correctBtn.onclick = () => {
                    gameState.players[gameState.currentTurnIndex].correctAnswers++;
                    gameState.correctAnswerGiven = true;
                    gameState.questionActive = false;
                    questionModal.classList.add('hidden');
                    questionModal.classList.remove('flex');
                    
                    // Add visual effect for correct answer
                    gameBoardContainer.classList.add('pulse-correct');
                    setTimeout(() => {
                        gameBoardContainer.classList.remove('pulse-correct');
                    }, 1500); // Duration of the animation (increased)

                    nextTurn(true);
                    resolve();
                };

                wrongBtn.onclick = () => {
                    gameState.correctAnswerGiven = false;
                    gameState.questionActive = false;
                    questionModal.classList.add('hidden');
                    questionModal.classList.remove('flex');
                    nextTurn(false);
                    resolve();
                };
            });
        }

        function nextTurn(reRoll = false) {
            if (!reRoll) {
                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.players.length;
            }
            updateCurrentPlayerDisplay();
        }

        function endGame(winnerName) {
            gameState.gameOver = true;
            gamePlayScreen.classList.add('hidden');
            gameOverModal.classList.remove('hidden');
            gameOverModal.classList.add('flex');

            gameOverTitle.textContent = `Partie Terminée ! ${winnerName} a gagné !`;
            gameOverMessage.textContent = "Voici un récapitulatif des bonnes réponses :";

            // Start confetti effect
            startConfetti();

            const playerNames = gameState.players.map(p => p.name);
            const correctAnswersCounts = gameState.players.map(p => p.correctAnswers);
            const playerColors = gameState.players.map(p => {
                if (p.colorClass === 'bg-player-1') return '#ef4444';
                if (p.colorClass === 'bg-player-2') return '#3b82f6';
                if (p.colorClass === 'bg-player-3') return '#22c55e';
                if (p.colorClass === 'bg-player-4') return '#f97316';
                if (p.colorClass === 'bg-player-5') return '#a855f7';
                if (p.colorClass === 'bg-player-6') return '#eab308';
                return '#ccc';
            });

            if (correctAnswersChart) {
                correctAnswersChart.destroy();
            }

            correctAnswersChart = new Chart(correctAnswersChartCanvas, {
                type: 'bar',
                data: {
                    labels: playerNames,
                    datasets: [{
                        label: 'Bonnes Réponses',
                        data: correctAnswersCounts,
                        backgroundColor: playerColors,
                        borderColor: playerColors.map(c => c + 'CC'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    if (Number.isInteger(value)) {
                                        return value;
                                    }
                                    return null;
                                }
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                callback: function(value, index, values) {
                                    const label = this.getLabelForValue(value);
                                    if (label.length > 16) {
                                        return label.split(' ').map((word, i, arr) => {
                                            if (word.length > 8 && i < arr.length - 1) return word + '-';
                                            return word;
                                        }).join(' ').match(/.{1,16}(\s|$)/g).map(s => s.trim());
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initial load of questions
        loadQuestions();
    </script>
</body>
</html>
