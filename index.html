<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu des Fables de La Fontaine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Chosen Palette: Calm Harmony (Stone, Emerald, Amber, Blue, Red) -->
    <!-- Application Structure Plan: L'application est une page unique organis√©e en plusieurs vues g√©r√©es par JavaScript (√©cran de d√©marrage/configuration des joueurs, plateau de jeu, modale de question, modale de fin de partie, et d√©sormais une modale de gestion des questions). Le plateau de jeu est une grille CSS flexible et r√©active, avec des cases num√©rot√©es et visuellement distinctes. Les interactions cl√©s incluent la saisie des noms des joueurs, le clic pour lancer le d√©, l'affichage et la gestion des questions/r√©ponses via une modale, la navigation entre les tours. Une nouvelle section de gestion des questions permet l'ajout, la modification et la suppression de contenu via localStorage. Cette structure est choisie pour sa clart√© et sa simplicit√©, permettant une transition fluide entre les phases de jeu et une exploration intuitive pour les √©l√®ves et les enseignants. -->
    <!-- Visualization & Content Choices: La "Source Report" ici est la description du jeu lui-m√™me. L'objectif est de traduire ces r√®gles en une exp√©rience interactive et d'ajouter une gestion de contenu. Le plateau de jeu (Goal: Organize/Play) est une grille HTML/CSS. Les pions des joueurs sont des emojis (Goal: Inform/Identify). Le d√© est une simple mise √† jour textuelle/num√©rique (Goal: Inform). Les questions sont des blocs de texte dynamiques (Goal: Inform/Challenge), pr√©sent√©s dans une modale. Une section de synth√®se en fin de partie (Goal: Inform/Summarize) utilise un graphique √† barres Chart.js pour visualiser les bonnes r√©ponses par joueur. La gestion des questions (Goal: Organize/Manage) est une modale avec des listes et formulaires HTML/CSS g√©r√©s par JS et stock√©s dans localStorage. Des effets sonores (Tone.js) et visuels (CSS keyframes) ont √©t√© ajout√©s pour renforcer l'immersion, incluant des confettis pour la victoire. Tous les √©l√©ments sont rendus avec HTML/CSS/JS et Chart.js, sans SVG ni Mermaid. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <style>
        body {
            font-family: 'Lato', sans-serif;
            background-color: #f5f5f4; /* stone-100 */
        }
        h1, h2, h3, .font-title {
            font-family: 'Merriweather', serif;
        }
        .board-cell {
            position: relative;
            background-color: #fcefdc; /* Light amber */
            border: 1px solid #d4c09d;
            border-radius: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #44403c; /* stone-700 */
            aspect-ratio: 1 / 1; /* Keep cells square */
        }
        .player-token {
            position: absolute;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.5s ease-in-out; /* Smooth movement */
        }
        .bg-player-1 { background-color: #ef4444; } /* Red */
        .bg-player-2 { background-color: #3b82f6; } /* Blue */
        .bg-player-3 { background-color: #22c55e; } /* Green */
        .bg-player-4 { background-color: #f97316; } /* Orange */
        .bg-player-5 { background-color: #a855f7; } /* Purple */
        .bg-player-6 { background-color: #eab308; } /* Yellow */

        /* Specific cell styles */
        .cell-start { background-color: #a7f3d0; } /* emerald-200 */
        .cell-end { background-color: #a78bfa; } /* violet-400 */
        .cell-bonus { background-color: #bfdbfe; } /* blue-200 */
        .cell-trap { background-color: #fecaca; } /* red-200 */

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.75rem;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            text-align: center;
        }

        /* Correct Answer Visual Effect */
        .pulse-correct {
            animation: pulse-effect 1.5s ease-out; /* Longer duration */
        }

        @keyframes pulse-effect {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(16, 185, 129, 0.4); } /* emerald-500 */
            50% { transform: scale(1.005); box-shadow: 0 0 15px rgba(16, 185, 129, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(16, 185, 129, 0); }
        }

        /* Confetti Styles */
        #confetti-container {
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 2000; /* Ensure it's above other elements */
        }

        .confetti-particle {
            position: absolute;
            background-color: transparent; /* Will be set by JS */
            border-radius: 50%; /* For round confetti */
            opacity: 0.9;
            transform-origin: center center;
            will-change: transform, opacity; /* Optimize animations */
        }

        @keyframes fall {
            0% { transform: translateY(0) rotateZ(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotateZ(720deg); opacity: 0.5; }
        }

        @keyframes rotate {
            0% { transform: rotateY(0deg) rotateX(0deg); }
            100% { transform: rotateY(360deg) rotateX(360deg); }
        }
    </style>
</head>
<body class="text-stone-800">

    <div id="app" class="container mx-auto p-4 md:p-6 max-w-6xl min-h-screen flex flex-col">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-5xl font-title font-bold text-stone-700">Le Grand Jeu des Fables</h1>
            <h2 class="text-xl md:text-2xl font-title text-stone-500">Un Voyage avec La Fontaine</h2>
        </header>

        <!-- Player Setup Screen -->
        <section id="player-setup-screen" class="flex flex-col items-center justify-center flex-grow p-4">
            <div class="bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-6 md:p-8 max-w-md w-full">
                <h3 class="text-2xl font-bold font-title text-stone-700 mb-4">Pr√©paration des Joueurs</h3>
                <div id="player-inputs" class="space-y-3 mb-6">
                    <!-- Player input fields will be added here -->
                </div>
                <button id="add-player-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mr-2">Ajouter un Joueur</button>
                <button id="start-game-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform duration-200 hover:scale-105">D√©marrer le Jeu</button>
                <button id="manage-questions-btn" class="bg-stone-500 hover:bg-stone-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mt-4 w-full">G√©rer les Questions</button>
            </div>
        </section>

        <!-- Game Play Screen -->
        <section id="game-play-screen" class="hidden flex-grow flex flex-col md:flex-row gap-6">
            
            <div id="game-board-container" class="order-2 md:order-1 bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-4 flex-grow grid grid-cols-5 auto-rows-min gap-2 md:gap-3">
                <!-- Board cells will be dynamically generated here -->
            </div>

            <div class="order-1 md:order-2 md:w-1/3 flex flex-col gap-4">
                <div class="bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-4 text-center">
                    <p class="text-lg md:text-xl font-semibold">C'est au tour de:</p>
                    <p id="current-player-name" class="text-2xl md:text-3xl font-bold font-title text-blue-600 mb-2"></p>
                    <p class="text-xl md:text-2xl font-bold">D√©:</p>
                    <div id="dice-display" class="text-5xl font-extrabold text-stone-700 mb-4 animate-bounce">?</div>
                    <button id="roll-dice-btn" class="bg-amber-500 hover:bg-amber-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform duration-200 hover:scale-105">Lancer le D√©</button>
                </div>

                <div class="bg-white/80 backdrop-blur-sm shadow-lg rounded-lg p-4">
                    <h3 class="text-xl font-bold font-title text-stone-700 mb-2 text-center">Positions des Joueurs</h3>
                    <ul id="player-positions-list" class="space-y-2">
                        <!-- Player positions will be listed here -->
                    </ul>
                </div>
            </div>
        </section>

        <!-- Question Modal -->
        <div id="question-modal" class="modal hidden">
            <div class="modal-content max-w-lg">
                <h3 class="text-2xl font-bold font-title text-stone-700 mb-4">Question !</h3>
                <p id="question-text" class="text-lg text-stone-700 mb-6"></p>
                <button id="reveal-answer-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105">R√©v√©ler la R√©ponse</button>
                <p id="answer-text" class="text-xl font-bold font-title text-emerald-700 mt-4 hidden"></p>
                <div class="flex justify-center gap-4 mt-6">
                    <button id="correct-answer-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 hidden">Bonne R√©ponse !</button>
                    <button id="wrong-answer-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 hidden">Mauvaise R√©ponse</button>
                </div>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-modal" class="modal hidden">
            <div class="modal-content max-w-2xl">
                <h3 id="game-over-title" class="text-3xl font-bold font-title text-stone-700 mb-4">Partie Termin√©e !</h3>
                <p id="game-over-message" class="text-xl text-stone-700 mb-6"></p>
                
                <div class="bg-gray-50 rounded-lg p-4 mb-6">
                    <h4 class="text-xl font-bold font-title text-stone-700 mb-3">Statistiques des Questions</h4>
                    <div class="chart-container w-full max-w-xl mx-auto h-[300px] md:h-[400px]">
                        <canvas id="correct-answers-chart"></canvas>
                    </div>
                </div>

                <button id="play-again-btn" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform duration-200 hover:scale-105">Rejouer</button>
            </div>
        </div>

        <!-- Question Management Modal -->
        <div id="question-management-modal" class="modal hidden">
            <div class="modal-content max-w-2xl">
                <h3 class="text-2xl font-bold font-title text-stone-700 mb-4">G√©rer les Questions</h3>
                
                <div class="text-left mb-6">
                    <h4 class="text-xl font-bold mb-2">Ajouter/Modifier une Question</h4>
                    <input type="hidden" id="question-id-field">
                    <label for="question-input" class="block text-stone-700 text-sm font-bold mb-1">Question :</label>
                    <textarea id="question-input" class="shadow appearance-none border rounded w-full py-2 px-3 text-stone-700 leading-tight focus:outline-none focus:shadow-outline mb-3" rows="3"></textarea>
                    
                    <label for="answer-input" class="block text-stone-700 text-sm font-bold mb-1">R√©ponse :</label>
                    <input type="text" id="answer-input" class="shadow appearance-none border rounded w-full py-2 px-3 text-stone-700 leading-tight focus:outline-none focus:shadow-outline mb-3">
                    
                    <button id="save-question-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg shadow transition-transform duration-200 hover:scale-105 mr-2">Sauvegarder la Question</button>
                    <button id="cancel-edit-btn" class="bg-stone-400 hover:bg-stone-500 text-white font-bold py-2 px-4 rounded-lg shadow transition-transform duration-200 hover:scale-105">Annuler</button>
                </div>

                <div class="text-left">
                    <h4 class="text-xl font-bold mb-2">Liste des Questions</h4>
                    <ul id="questions-list" class="space-y-2 max-h-80 overflow-y-auto border border-stone-200 p-2 rounded-md">
                        <!-- Questions will be listed here -->
                    </ul>
                </div>
                
                <button id="close-management-modal-btn" class="bg-stone-600 hover:bg-stone-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mt-6">Fermer</button>
            </div>
        </div>

    </div>

    <!-- Confetti container -->
    <div id="confetti-container" class="fixed inset-0 overflow-hidden hidden"></div>

    <script>
        // D√©finition de la fonction shuffle, d√©plac√©e plus haut pour garantir sa disponibilit√©
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        const defaultQuestions = [
            { id: 'q1', q: "Qui suis-je ? Je suis paresseuse et je chante tout l'√©t√©, sans penser √† l'hiver.", a: "La Cigale" },
            { id: 'q2', q: "Quel est le titre de la fable o√π un animal rus√© vole le fromage d'un oiseau vaniteux ?", a: "Le Corbeau et le Renard" },
            { id: 'q3', q: "Comment appelle-t-on la le√ßon de vie ou la conclusion didactique √† la fin d'une fable ?", a: "La Moralit√©" },
            { id: 'q4', q: "Qui suis-je ? Je suis fort et puissant, mais je peux √™tre cl√©ment envers les petits.", a: "Le Lion" },
            { id: 'q5', q: "Quel est le titre de la fable o√π le plus fort impose sa loi au plus faible ?", a: "Le Loup et l'Agneau" },
            { id: 'q6', q: "Comment s'appelle un vers de douze syllabes, tr√®s utilis√© en po√©sie classique fran√ßaise ?", a: "L'Alexandrin" },
            { id: 'q7', q: "Qui suis-je ? Je suis tr√®s pr√©voyante et je travaille sans rel√¢che pendant que d'autres s'amusent.", a: "La Fourmi" },
            { id: 'q8', q: "Quel est le titre de la fable o√π un lent mais pers√©v√©rant gagne une course contre un rapide mais arrogant ?", a: "Le Li√®vre et la Tortue" },
            { id: 'q9', q: "Comment appelle-t-on la r√©p√©tition de sons identiques √† la fin de deux ou plusieurs vers ?", a: "La Rime" },
            { id: 'q10', q: "Qui suis-je ? Je suis tr√®s lent et mon corps est recouvert d'une carapace.", a: "La Tortue" },
            { id: 'q11', q: "Quel est le titre de la fable o√π un arbre solide plie devant un √©v√©nement, contrairement √† un autre plus souple ?", a: "Le Ch√™ne et le Roseau" },
            { id: 'q12', q: "Comment appelle-t-on un r√©cit court et imag√©, souvent avec des animaux qui parlent, et qui contient une le√ßon de vie ?", a: "Une Fable" },
            { id: 'q13', q: "Qui suis-je ? Je suis assoiff√©, mais le courant m'emp√™che de boire en paix pr√®s de mon ennemi.", a: "L'Agneau" },
            { id: 'q14', q: "Quel est le titre de la fable o√π une femme r√™ve de vendre le lait de son pot, mais casse tout par m√©garde ?", a: "La Laiti√®re et le Pot au Lait" },
            { id: 'q15', q: "Comment appelle-t-on le fait qu'une voyelle ou un 'e' muet ne soit pas prononc√© √† la fin d'un mot, devant une autre voyelle, pour compter les syllabes d'un vers ?", a: "L'√âlision" },
            { id: 'q16', q: "Qui suis-je ? Je me suis fait tr√®s gros pour ressembler √† un b≈ìuf, mais j'ai fini par √©clater.", a: "La Grenouille" },
            { id: 'q17', q: "Quel est le titre de la fable o√π les animaux sont malades, et le loup propose un coupable ?", a: "Les Animaux malades de la peste" },
            { id: 'q18', q: "Comment s'appelle un vers de huit syllabes ?", a: "L'Octosyllabe" },
            { id: 'q19', q: "Qui suis-je ? J'ai √©chapp√© √† mon ennemi en lui faisant chanter une chanson pour lui voler son repas.", a: "Le Corbeau" },
            { id: 'q20', q: "Quel est le titre de la fable qui oppose la vie agit√©e de la ville √† la vie tranquille de la campagne ?", a: "Le Rat de ville et le Rat des champs" }
        ];

        const playerTokens = ['üê∞', 'ü¶ä', 'üê¢', 'ü¶Å', 'üê∫', 'üêú'];
        const boardLength = 35; // Cells from 0 to 34
        const specialCells = {
            4: { type: 'bonus', effect: 2, text: '+2 cases' },
            9: { type: 'trap', effect: -3, text: '-3 cases' },
            13: { type: 'bonus', effect: 3, text: '+3 cases' },
            18: { type: 'trap', effect: 'swap', text: '√âchange avec le moins avanc√©' },
            22: { type: 'bonus', effect: 5, text: '+5 cases' },
            27: { type: 'trap', effect: 'start', text: 'Retour √† la case d√©part' }
        };

        let gameState = {
            players: [],
            board: [],
            currentTurnIndex: 0,
            gameStarted: false,
            gameOver: false,
            availableQuestionIds: [], // IDs of questions not yet asked in current game
            questionsData: [], // All questions loaded from localStorage
            questionBeingAsked: null,
            correctAnswerGiven: false
        };

        const playerSetupScreen = document.getElementById('player-setup-screen');
        const playerInputsDiv = document.getElementById('player-inputs');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const startGameBtn = document.getElementById('start-game-btn');
        const manageQuestionsBtn = document.getElementById('manage-questions-btn');
        const gamePlayScreen = document.getElementById('game-play-screen');
        const gameBoardContainer = document.getElementById('game-board-container');
        const currentPlayerNameSpan = document.getElementById('current-player-name');
        const diceDisplay = document.getElementById('dice-display');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const playerPositionsList = document.getElementById('player-positions-list');
        const questionModal = document.getElementById('question-modal');
        const questionText = document.getElementById('question-text');
        const revealAnswerBtn = document.getElementById('reveal-answer-btn');
        const answerText = document.getElementById('answer-text');
        const correctBtn = document.getElementById('correct-answer-btn');
        const wrongBtn = document.getElementById('wrong-answer-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');
        const playAgainBtn = document.getElementById('play-again-btn');
        const correctAnswersChartCanvas = document.getElementById('correct-answers-chart');
        let correctAnswersChart = null;

        const questionManagementModal = document.getElementById('question-management-modal');
        const questionsList = document.getElementById('questions-list');
        const questionIdField = document.getElementById('question-id-field');
        const questionInput = document.getElementById('question-input');
        const answerInput = document.getElementById('answer-input');
        const saveQuestionBtn = document.getElementById('save-question-btn');
        const cancelEditBtn = document.getElementById('cancel-edit-btn');
        const closeManagementModalBtn = document.getElementById('close-management-modal-btn');

        // Confetti variables
        let confettiInterval;
        let confettiDuration = 30000; // 30 seconds
        let confettiCount = 0;
        const maxConfetti = 200; 
        const confettiContainer = document.getElementById('confetti-container');

        // --- Tone.js Sound Setups ---
        const bonusSynth = new Tone.MembraneSynth().toDestination();
        // Adjusting trapSynth for a longer, more eerie sound
        const trapSynth = new Tone.DuoSynth({
            "vibratoAmount": 0.5,
            "vibratoRate": 5,
            "harmonicity": 1.5,
            "voice0": {
                "volume": -10,
                "portamento": 0,
                "oscillator": { "type": "sine" },
                "filterEnvelope": {
                    "attack": 0.01,
                    "decay": 1.0, // Longer decay
                    "sustain": 0.4,
                    "release": 1.0, // Longer release
                    "baseFrequency": 200,
                    "octaves": 4,
                    "exponent": 2
                },
                "envelope": {
                    "attack": 0.01,
                    "decay": 0.5,
                    "sustain": 0.4,
                    "release": 2.0 // Very long release
                }
            },
            "voice1": {
                "volume": -10,
                "portamento": 0,
                "oscillator": { "type": "sine" },
                "filterEnvelope": {
                    "attack": 0.01,
                    "decay": 1.0, // Longer decay
                    "sustain": 0.4,
                    "release": 1.0, // Longer release
                    "baseFrequency": 200,
                    "octaves": 4,
                    "exponent": 2
                },
                "envelope": {
                    "attack": 0.01,
                    "decay": 0.5,
                    "sustain": 0.4,
                    "release": 2.0 // Very long release
                }
            }
        }).toDestination();


        function playBonusSound() {
            bonusSynth.triggerAttackRelease("C5", "4n"); // Longer duration for bonus
        }

        function playTrapSound() {
            trapSynth.triggerAttackRelease("C3", "2n"); // Longer duration for trap
        }

        function createConfetti() {
            if (confettiCount >= maxConfetti) return;

            const confetti = document.createElement('div');
            confetti.classList.add('confetti-particle');
            
            const colors = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#a855f7', '#eab308'];
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            
            const size = Math.random() * 10 + 5; // 5px to 15px
            confetti.style.width = `${size}px`;
            confetti.style.height = `${size}px`;
            
            confetti.style.left = `${Math.random() * 100}vw`;
            confetti.style.top = `-${size}px`; // Start above screen
            
            const duration = Math.random() * 3 + 2; // 2s to 5s
            const delay = Math.random() * 0.5; // 0s to 0.5s
            confetti.style.animation = `fall ${duration}s linear ${delay}s infinite, rotate ${Math.random() * 2 + 1}s linear infinite`;
            
            confettiContainer.appendChild(confetti);
            confettiCount++;

            // Remove confetti after it falls off screen (or a bit after its animation duration)
            setTimeout(() => {
                if (confetti.parentNode) {
                    confetti.parentNode.removeChild(confetti);
                    confettiCount--;
                }
            }, (duration + delay) * 1000 + 500); 
        }

        function startConfetti() {
            confettiContainer.classList.remove('hidden');
            confettiCount = 0;
            for (let i = 0; i < 50; i++) {
                createConfetti();
            }
            confettiInterval = setInterval(createConfetti, 100);

            setTimeout(() => {
                clearInterval(confettiInterval);
                stopConfetti();
            }, confettiDuration);
        }

        function stopConfetti() {
            if (confettiInterval) {
                clearInterval(confettiInterval);
            }
            confettiContainer.classList.add('hidden');
            confettiContainer.innerHTML = '';
            confettiCount = 0;
        }


        // --- Question Management Logic ---
        function loadQuestions() {
            const storedQuestions = localStorage.getItem('fablesQuestions');
            if (storedQuestions) {
                try {
                    gameState.questionsData = JSON.parse(storedQuestions);
                } catch (e) {
                    console.error("Error parsing stored questions, loading default.", e);
                    gameState.questionsData = defaultQuestions;
                    saveQuestions(); // Save defaults if parsing fails
                }
            } else {
                gameState.questionsData = defaultQuestions;
                saveQuestions();
            }
        }

        function saveQuestions() {
            localStorage.setItem('fablesQuestions', JSON.stringify(gameState.questionsData));
            renderQuestionsList(); // Update UI after saving
        }

        function generateUniqueId() {
            return 'q' + Date.now() + Math.random().toString(36).substr(2, 9);
        }

        function renderQuestionsList() {
            questionsList.innerHTML = '';
            if (gameState.questionsData.length === 0) {
                questionsList.innerHTML = '<li class="text-stone-500">Aucune question n\'a √©t√© ajout√©e.</li>';
                return;
            }
            gameState.questionsData.forEach(q => {
                const li = document.createElement('li');
                li.className = 'flex flex-col md:flex-row justify-between items-start md:items-center p-2 border-b border-stone-200 last:border-b-0';
                li.innerHTML = `
                    <div class="flex-grow text-sm mb-2 md:mb-0">
                        <p class="font-semibold text-stone-700">${q.q}</p>
                        <p class="text-stone-500">R√©ponse: ${q.a}</p>
                    </div>
                    <div class="flex gap-2">
                        <button data-id="${q.id}" class="edit-question-btn bg-yellow-500 hover:bg-yellow-600 text-white text-xs py-1 px-2 rounded-md shadow-sm">Modifier</button>
                        <button data-id="${q.id}" class="delete-question-btn bg-red-500 hover:bg-red-600 text-white text-xs py-1 px-2 rounded-md shadow-sm">Supprimer</button>
                    </div>
                `;
                questionsList.appendChild(li);
            });

            document.querySelectorAll('.edit-question-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const qId = e.target.dataset.id;
                    const questionToEdit = gameState.questionsData.find(q => q.id === qId);
                    if (questionToEdit) {
                        questionIdField.value = questionToEdit.id;
                        questionInput.value = questionToEdit.q;
                        answerInput.value = questionToEdit.a;
                    }
                });
            });

            document.querySelectorAll('.delete-question-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const qId = e.target.dataset.id;
                    gameState.questionsData = gameState.questionsData.filter(q => q.id !== qId);
                    saveQuestions();
                });
            });
        }

        function clearQuestionForm() {
            questionIdField.value = '';
            questionInput.value = '';
            answerInput.value = '';
        }

        saveQuestionBtn.addEventListener('click', () => {
            const id = questionIdField.value;
            const q = questionInput.value.trim();
            const a = answerInput.value.trim();

            if (!q || !a) {
                alert("Veuillez remplir la question et la r√©ponse.");
                return;
            }

            if (id) {
                // Edit existing
                const index = gameState.questionsData.findIndex(item => item.id === id);
                if (index !== -1) {
                    gameState.questionsData[index] = { id, q, a };
                }
            } else {
                // Add new
                gameState.questionsData.push({ id: generateUniqueId(), q, a });
            }
            saveQuestions();
            clearQuestionForm();
        });

        cancelEditBtn.addEventListener('click', clearQuestionForm);

        manageQuestionsBtn.addEventListener('click', () => {
            loadQuestions(); // Ensure latest questions are loaded when opening
            renderQuestionsList();
            questionManagementModal.classList.remove('hidden');
            questionManagementModal.classList.add('flex');
        });

        closeManagementModalBtn.addEventListener('click', () => {
            questionManagementModal.classList.add('hidden');
            questionManagementModal.classList.remove('flex');
            clearQuestionForm(); // Clear form when closing
        });

        // --- Player Setup Logic ---
        let playerCount = 0;
        function addPlayerInput() {
            if (playerCount >= 6) return; // Max 6 players/teams
            playerCount++;
            const div = document.createElement('div');
            div.className = 'flex items-center gap-2';
            div.innerHTML = `
                <span class="font-bold text-lg text-stone-700">Joueur ${playerCount} (${playerTokens[playerCount - 1]}):</span>
                <input type="text" id="player-name-${playerCount}" placeholder="Nom de l'√©quipe" class="p-2 border border-stone-300 rounded-md flex-grow" value="√âquipe ${playerCount}" />
            `;
            playerInputsDiv.appendChild(div);
        }

        // Initialize with 2 players by default
        addPlayerInput();
        addPlayerInput();

        addPlayerBtn.addEventListener('click', addPlayerInput);
        startGameBtn.addEventListener('click', initializeGame);
        playAgainBtn.addEventListener('click', () => {
            stopConfetti(); // Stop confetti if playing again
            gameOverModal.classList.add('hidden');
            playerSetupScreen.classList.remove('hidden');
            gamePlayScreen.classList.add('hidden');
            gameState = { players: [], board: [], currentTurnIndex: 0, gameStarted: false, gameOver: false, availableQuestionIds: [], questionsData: gameState.questionsData, questionBeingAsked: null, correctAnswerGiven: false }; // Keep questionsData
            playerInputsDiv.innerHTML = ''; // Clear previous inputs
            playerCount = 0;
            addPlayerInput();
            addPlayerInput();
            if (correctAnswersChart) {
                correctAnswersChart.destroy();
                correctAnswersChart = null;
            }
        });

        // --- Game Initialization ---
        function initializeGame() {
            loadQuestions(); // Ensure questions are loaded before starting a game
            if (gameState.questionsData.length === 0) {
                alert("La banque de questions est vide ! Veuillez ajouter des questions avant de commencer.");
                return;
            }

            gameState.players = [];
            for (let i = 1; i <= playerCount; i++) {
                const nameInput = document.getElementById(`player-name-${i}`);
                gameState.players.push({
                    name: nameInput.value || `Joueur ${i}`,
                    position: 0, // 0-indexed for array, represents cell 1
                    token: playerTokens[i - 1],
                    colorClass: `bg-player-${i}`,
                    correctAnswers: 0
                });
            }

            if (gameState.players.length < 2) {
                alert("Il faut au moins 2 joueurs pour d√©marrer le jeu !");
                return;
            }

            gameState.board = Array(boardLength).fill('normal');
            gameState.board[0] = 'start';
            gameState.board[boardLength - 1] = 'end'; // Last cell is end

            for (const pos in specialCells) {
                if (parseInt(pos) < boardLength - 1 ) { // Ensure special cells are not on the very last one
                    gameState.board[pos] = specialCells[pos].type;
                }
            }

            gameState.currentTurnIndex = Math.floor(Math.random() * gameState.players.length);
            gameState.gameStarted = true;
            gameState.gameOver = false;
            
            // Populate available questions for this game
            gameState.availableQuestionIds = gameState.questionsData.map(q => q.id);
            shuffle(gameState.availableQuestionIds); // Shuffle once at the beginning

            playerSetupScreen.classList.add('hidden');
            gamePlayScreen.classList.remove('hidden');
            renderBoard();
            updatePlayerPositionsList();
            updateCurrentPlayerDisplay();
        }

        // --- Board Rendering ---
        function renderBoard() {
            gameBoardContainer.innerHTML = '';
            for (let i = 0; i < boardLength; i++) {
                const cell = document.createElement('div');
                cell.className = 'board-cell shadow-sm';
                cell.textContent = i + 1; // Display 1-indexed number

                // Add specific styles for special cells
                if (i === 0) cell.classList.add('cell-start');
                else if (i === boardLength - 1) cell.classList.add('cell-end');
                else if (specialCells[i]) {
                    if (specialCells[i].type === 'bonus') cell.classList.add('cell-bonus');
                    else if (specialCells[i].type === 'trap') cell.classList.add('cell-trap');
                }
                
                cell.id = `cell-${i}`;
                gameBoardContainer.appendChild(cell);
            }
            placePlayerTokens();
        }

        function placePlayerTokens() {
            gameState.players.forEach(player => {
                const currentCell = document.getElementById(`cell-${player.position}`);
                if (currentCell) {
                    let token = document.getElementById(`token-${player.name.replace(/\s/g, '-')}`);
                    if (!token) {
                        token = document.createElement('div');
                        token.id = `token-${player.name.replace(/\s/g, '-')}`;
                        token.className = `player-token ${player.colorClass}`;
                        token.textContent = player.token;
                        token.title = player.name;
                    }
                    currentCell.appendChild(token);
                }
            });
        }

        function updatePlayerPositionsList() {
            playerPositionsList.innerHTML = '';
            gameState.players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'flex items-center justify-between text-lg';
                li.innerHTML = `
                    <span class="flex items-center gap-2">
                        <span class="${player.colorClass} w-5 h-5 rounded-full flex items-center justify-center text-sm text-white">${player.token}</span>
                        <span>${player.name}</span>
                    </span>
                    <span class="font-bold">${player.position + 1}</span>
                `;
                playerPositionsList.appendChild(li);
            });
        }

        function updateCurrentPlayerDisplay() {
            const currentPlayer = gameState.players[gameState.currentTurnIndex];
            currentPlayerNameSpan.textContent = currentPlayer.name;
            currentPlayerNameSpan.className = `text-2xl md:text-3xl font-bold font-title ${currentPlayer.colorClass.replace('bg-', 'text-')}`;
        }

        // --- Game Play Logic ---
        rollDiceBtn.addEventListener('click', rollDice);

        async function rollDice() {
            if (gameState.gameOver || gameState.questionActive) return;

            rollDiceBtn.disabled = true;
            diceDisplay.classList.remove('animate-bounce'); // Stop initial animation

            let rollCount = 0;
            const animationInterval = setInterval(() => {
                diceDisplay.textContent = Math.floor(Math.random() * 6) + 1;
                rollCount++;
                if (rollCount > 10) {
                    clearInterval(animationInterval);
                    const roll = Math.floor(Math.random() * 6) + 1;
                    diceDisplay.textContent = roll;
                    movePlayer(roll);
                    rollDiceBtn.disabled = false;
                }
            }, 100);
        }

        async function movePlayer(roll) {
            const currentPlayer = gameState.players[gameState.currentTurnIndex];
            let newPosition = currentPlayer.position + roll;

            if (newPosition >= boardLength -1) {
                newPosition = boardLength -1;
            }
            
            for (let i = currentPlayer.position; i < newPosition; i++) {
                await new Promise(resolve => setTimeout(() => {
                    currentPlayer.position = i + 1;
                    placePlayerTokens();
                    updatePlayerPositionsList();
                    resolve();
                }, 200));
            }

            currentPlayer.position = newPosition;
            placePlayerTokens();
            updatePlayerPositionsList();

            checkCell(newPosition);
        }

        async function checkCell(position) {
            if (position === boardLength - 1) {
                endGame(gameState.players[gameState.currentTurnIndex].name);
                return;
            }

            const cellType = gameState.board[position];
            
            if (specialCells[position]) {
                const effect = specialCells[position].effect;
                const currentPlayer = gameState.players[gameState.currentTurnIndex];
                
                let message = "";

                if (specialCells[position].type === 'bonus') {
                    playBonusSound(); // Play bonus sound
                } else if (specialCells[position].type === 'trap') {
                    playTrapSound(); // Play trap sound
                }


                if (effect === 'swap') {
                    const leastAdvancedPlayer = gameState.players.reduce((prev, curr) => 
                        curr.position < prev.position ? curr : prev, gameState.players[0]);
                    
                    if (leastAdvancedPlayer.name !== currentPlayer.name) {
                        const currentPlayerOldPos = currentPlayer.position;
                        const leastAdvancedPlayerOldPos = leastAdvancedPlayer.position;
                        
                        currentPlayer.position = leastAdvancedPlayerOldPos;
                        leastAdvancedPlayer.position = currentPlayerOldPos;
                        
                        message = `${currentPlayer.name} √©change sa place avec ${leastAdvancedPlayer.name} !`;
                        placePlayerTokens();
                        updatePlayerPositionsList();
                    } else {
                        message = `${currentPlayer.name} est d√©j√† le moins avanc√©. Rien ne se passe !`;
                    }
                     await showEventMessage("√âv√©nement Sp√©cial !", message);
                     nextTurn();
                     return;

                } else if (effect === 'start') {
                    currentPlayer.position = 0;
                    message = `${currentPlayer.name} retourne √† la case d√©part !`;
                    placePlayerTokens();
                    updatePlayerPositionsList();
                    await showEventMessage("√âv√©nement Sp√©cial !", message);
                    nextTurn();
                    return;
                } else if (typeof effect === 'number') {
                    let newPos = currentPlayer.position + effect;
                    if (newPos < 0) newPos = 0;
                    if (newPos >= boardLength - 1) newPos = boardLength -1;
                    
                    currentPlayer.position = newPos;

                    if (effect > 0) {
                        message = `${currentPlayer.name} avance de ${effect} cases !`;
                    } else {
                        message = `${currentPlayer.name} recule de ${Math.abs(effect)} cases !`;
                    }
                    placePlayerTokens();
                    updatePlayerPositionsList();
                    await showEventMessage("√âv√©nement Sp√©cial !", message);
                    nextTurn();
                    return;
                }
            }
            
            await askQuestion();
        }

        function showEventMessage(title, message) {
            return new Promise(resolve => {
                questionModal.classList.remove('hidden');
                questionModal.classList.add('flex');
                questionModal.querySelector('.modal-content h3').textContent = title;
                questionText.textContent = message;
                revealAnswerBtn.classList.add('hidden');
                answerText.classList.add('hidden');
                correctBtn.classList.add('hidden');
                wrongBtn.classList.add('hidden');

                const okButton = document.createElement('button');
                okButton.textContent = "OK";
                okButton.className = "bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-transform duration-200 hover:scale-105 mt-6";
                okButton.onclick = () => {
                    questionModal.classList.add('hidden');
                    questionModal.classList.remove('flex');
                    okButton.remove();
                    questionModal.querySelector('.modal-content h3').textContent = "Question !"; // Reset title
                    resolve();
                };
                questionModal.querySelector('.modal-content').appendChild(okButton);
            });
        }


        function askQuestion() {
            return new Promise(resolve => {
                gameState.questionActive = true;
                
                if (gameState.availableQuestionIds.length === 0) {
                    showEventMessage("Plus de questions !", "Vous avez r√©pondu √† toutes les questions disponibles ! La partie continue sans questions.");
                    gameState.questionActive = false; // Allow play to continue
                    resolve();
                    return;
                }

                // Pick a random question from available ones
                const randomIndex = Math.floor(Math.random() * gameState.availableQuestionIds.length);
                const questionId = gameState.availableQuestionIds[randomIndex];
                gameState.questionBeingAsked = gameState.questionsData.find(q => q.id === questionId);

                // Remove from available questions
                gameState.availableQuestionIds.splice(randomIndex, 1);

                questionText.textContent = gameState.questionBeingAsked.q;
                answerText.textContent = gameState.questionBeingAsked.a;

                answerText.classList.add('hidden');
                revealAnswerBtn.classList.remove('hidden');
                correctBtn.classList.add('hidden');
                wrongBtn.classList.add('hidden');

                questionModal.classList.remove('hidden');
                questionModal.classList.add('flex');

                revealAnswerBtn.onclick = () => {
                    answerText.classList.remove('hidden');
                    revealAnswerBtn.classList.add('hidden');
                    correctBtn.classList.remove('hidden');
                    wrongBtn.classList.remove('hidden');
                };

                correctBtn.onclick = () => {
                    gameState.players[gameState.currentTurnIndex].correctAnswers++;
                    gameState.correctAnswerGiven = true;
                    gameState.questionActive = false;
                    questionModal.classList.add('hidden');
                    questionModal.classList.remove('flex');
                    
                    // Add visual effect for correct answer
                    gameBoardContainer.classList.add('pulse-correct');
                    setTimeout(() => {
                        gameBoardContainer.classList.remove('pulse-correct');
                    }, 1500); // Duration of the animation (increased)

                    nextTurn(true);
                    resolve();
                };

                wrongBtn.onclick = () => {
                    gameState.correctAnswerGiven = false;
                    gameState.questionActive = false;
                    questionModal.classList.add('hidden');
                    questionModal.classList.remove('flex');
                    nextTurn(false);
                    resolve();
                };
            });
        }

        function nextTurn(reRoll = false) {
            if (!reRoll) {
                gameState.currentTurnIndex = (gameState.currentTurnIndex + 1) % gameState.players.length;
            }
            updateCurrentPlayerDisplay();
        }

        function endGame(winnerName) {
            gameState.gameOver = true;
            gamePlayScreen.classList.add('hidden');
            gameOverModal.classList.remove('hidden');
            gameOverModal.classList.add('flex');

            gameOverTitle.textContent = `Partie Termin√©e ! ${winnerName} a gagn√© !`;
            gameOverMessage.textContent = "Voici un r√©capitulatif des bonnes r√©ponses :";

            // Start confetti effect
            startConfetti();

            const playerNames = gameState.players.map(p => p.name);
            const correctAnswersCounts = gameState.players.map(p => p.correctAnswers);
            const playerColors = gameState.players.map(p => {
                if (p.colorClass === 'bg-player-1') return '#ef4444';
                if (p.colorClass === 'bg-player-2') return '#3b82f6';
                if (p.colorClass === 'bg-player-3') return '#22c55e';
                if (p.colorClass === 'bg-player-4') return '#f97316';
                if (p.colorClass === 'bg-player-5') return '#a855f7';
                if (p.colorClass === 'bg-player-6') return '#eab308';
                return '#ccc';
            });

            if (correctAnswersChart) {
                correctAnswersChart.destroy();
            }

            correctAnswersChart = new Chart(correctAnswersChartCanvas, {
                type: 'bar',
                data: {
                    labels: playerNames,
                    datasets: [{
                        label: 'Bonnes R√©ponses',
                        data: correctAnswersCounts,
                        backgroundColor: playerColors,
                        borderColor: playerColors.map(c => c + 'CC'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    if (Number.isInteger(value)) {
                                        return value;
                                    }
                                    return null;
                                }
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                callback: function(value, index, values) {
                                    const label = this.getLabelForValue(value);
                                    if (label.length > 16) {
                                        return label.split(' ').map((word, i, arr) => {
                                            if (word.length > 8 && i < arr.length - 1) return word + '-';
                                            return word;
                                        }).join(' ').match(/.{1,16}(\s|$)/g).map(s => s.trim());
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Initial load of questions
        loadQuestions();
    </script>
</body>
</html>
